{"version":3,"sources":["../../../../src/visualBuilder/utils/createCachedFetch.ts"],"sourcesContent":["/**\n * Creates a cached async fetch function with support for any number of arguments\n * @param fetchFn - The async function to cache\n * @param uidResolver - Function that generates a unique ID from the arguments passed to fetchFn\n * @returns A cached version of the fetch function with the same signature\n */\nexport function createCachedFetch<TArgs extends any[], TResult>(\n    fetchFn: (...args: TArgs) => Promise<TResult>,\n    uidResolver: (...args: TArgs) => string = (...args) => JSON.stringify(args)\n): {\n    (...args: TArgs): Promise<TResult>;\n    clearCache: () => void;\n} {\n    // Cache storage\n    const cache = new Map<string, TResult>();\n    // Track in-flight requests\n    const pendingPromises = new Map<string, Promise<TResult>>();\n\n    /**\n     * The cached fetch function\n     * @param args - Arguments to pass to the original fetch function\n     * @returns Promise that resolves with the data\n     */\n    async function cachedFetch(...args: TArgs): Promise<TResult> {\n        // Generate unique ID for these arguments\n        const uid = uidResolver(...args);\n\n        // Return cached value if available\n        if (cache.has(uid)) {\n            return cache.get(uid)!;\n        }\n\n        // Return existing promise if request is already in progress\n        if (pendingPromises.has(uid)) {\n            return pendingPromises.get(uid)!;\n        }\n\n        // Create new promise for this request\n        const promise = fetchFn(...args)\n            .then((data) => {\n                // Store result in cache\n                cache.set(uid, data);\n                // Remove from pending\n                pendingPromises.delete(uid);\n                return data;\n            })\n            .catch((error) => {\n                // Clean up on error\n                pendingPromises.delete(uid);\n                throw error;\n            });\n\n        // Store the promise\n        pendingPromises.set(uid, promise);\n        return promise;\n    }\n\n    // Add clearCache method to the function\n    cachedFetch.clearCache = () => {\n        cache.clear();\n        pendingPromises.clear();\n    };\n\n    return cachedFetch;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAMO,SAAS,kBACZ,SACA,cAA0C,IAAI,SAAS,KAAK,UAAU,IAAI,GAI5E;AAEE,QAAM,QAAQ,oBAAI,IAAqB;AAEvC,QAAM,kBAAkB,oBAAI,IAA8B;AAO1D,iBAAe,eAAe,MAA+B;AAEzD,UAAM,MAAM,YAAY,GAAG,IAAI;AAG/B,QAAI,MAAM,IAAI,GAAG,GAAG;AAChB,aAAO,MAAM,IAAI,GAAG;AAAA,IACxB;AAGA,QAAI,gBAAgB,IAAI,GAAG,GAAG;AAC1B,aAAO,gBAAgB,IAAI,GAAG;AAAA,IAClC;AAGA,UAAM,UAAU,QAAQ,GAAG,IAAI,EAC1B,KAAK,CAAC,SAAS;AAEZ,YAAM,IAAI,KAAK,IAAI;AAEnB,sBAAgB,OAAO,GAAG;AAC1B,aAAO;AAAA,IACX,CAAC,EACA,MAAM,CAAC,UAAU;AAEd,sBAAgB,OAAO,GAAG;AAC1B,YAAM;AAAA,IACV,CAAC;AAGL,oBAAgB,IAAI,KAAK,OAAO;AAChC,WAAO;AAAA,EACX;AAGA,cAAY,aAAa,MAAM;AAC3B,UAAM,MAAM;AACZ,oBAAgB,MAAM;AAAA,EAC1B;AAEA,SAAO;AACX;","names":[]}